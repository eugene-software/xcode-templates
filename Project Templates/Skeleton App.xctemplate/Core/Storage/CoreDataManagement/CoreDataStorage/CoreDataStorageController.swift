//
//  CoreDataStorageController.swift
//  TempProject
//
//  Created Eugeniy Zaychenko on 11/12/21.
//  Copyright Â© 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file is generated by custom SKELETON Xcode template.
//

import Foundation
import CoreData
import FirebaseCrashlytics

class FrameworkPersistentContainer: NSPersistentContainer {}

private extension DispatchQueue {
    static var coreDataConcurrent: DispatchQueue = DispatchQueue(label: UUID().uuidString, qos: .userInitiated, attributes: .concurrent)
}

class CoreDataStorageController: NSObject {
    
    //Static Properties
    //
    static var shared: CoreDataStorageInterface = {
        return CoreDataStorageController(completionClosure: nil)
    }()
    
    //Private Properties
    //
    private var persistentContainer: NSPersistentContainer!
    private var backgroundContext: NSManagedObjectContext?
    
    //Public Properties
    //
    var viewContext: NSManagedObjectContext {
        return persistentContainer.viewContext
    }
    
    init(completionClosure: (() -> Void)?) {
        
        super.init()
        loadStore(completionClosure: completionClosure)
    }
    
    func loadStore(completionClosure: (() -> Void)?) {
        
        persistentContainer = FrameworkPersistentContainer(name: "ModelAltos")
        persistentContainer.loadPersistentStores() { (description, error) in
            if let error = error {
                Crashlytics.crashlytics().record(error: error)
                print("Failed to load Core Data stack: \(error)")
            }
            completionClosure?()
        }
        
        // Initialize background context to perform all operations in background.
        //
        backgroundContext = persistentContainer.newBackgroundContext()
        backgroundContext?.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        persistentContainer.viewContext.automaticallyMergesChangesFromParent = true
        persistentContainer.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
    }
}


//MARK: - DataStorageInterface

extension CoreDataStorageController: CoreDataStorageInterface {
    
    func fetchedResultsProvider<Type: CoreDataCompatible>(_ type: Type.Type,
                                                          mainPredicate: NSPredicate,
                                                          optionalPredicates: [NSPredicate]?,
                                                          sorting sortDescriptors: [NSSortDescriptor],
                                                          sectionName: String?,
                                                          fetchLimit: Int?) -> FetchedResultsProviderInterface
    {
        return FetchedResultsProvider<Type>(mainPredicate,
                                            optionalPredicates: optionalPredicates,
                                            sorting: sortDescriptors,
                                            context: viewContext,
                                            sectionName: sectionName,
                                            fetchLimit: fetchLimit)
    }
    
    func insertList<Type: CoreDataCompatible>(objects: [Type?], completion: @escaping () -> Void) {
        
        let objects = objects.compactMap {$0}
        
        save {
            objects.forEach {
                let predicate = NSPredicate(key: $0.primaryKeyName, value: $0.primaryKey)
                self.insert(object: $0, predicate: predicate, context: self.backgroundContext!)
            }
        } completionBlock: {
            completion()
        }
    }
    
    func query<Type: CoreDataExportable>(type: Type.Type,
                                         predicate: NSPredicate?,
                                         sortDescriptors: [NSSortDescriptor]?,
                                         fetchLimit: Int?) -> [Type]? {
        return query(type: type, predicate: predicate, context: viewContext, sortDescriptors: sortDescriptors, fetchLimit: fetchLimit)
    }
    
    func asyncQuery<Type: CoreDataExportable>(type: Type.Type,
                                              predicate: NSPredicate?,
                                              sortDescriptors: [NSSortDescriptor]?,
                                              fetchLimit: Int?,
                                              completion: @escaping ([Type]?) -> Void) {
        
        let context = backgroundContext
        
        context?.perform { [weak self] in
            let result = self?.query(type: type, predicate: predicate, context: context!, sortDescriptors: sortDescriptors, fetchLimit: fetchLimit)
            completion(result)
        }
    }
    
    func delete<Type: CoreDataExportable>(_ type: Type.Type, with predicate: NSPredicate?, completion: @escaping () -> Void) {
        
        let context = backgroundContext
        
        let entityName = String(describing: Type.self)
        let fetchRequest = NSFetchRequest<Type>(entityName: entityName)
        fetchRequest.predicate = predicate
        
        save {
            let result = context?.safeFetch(fetchRequest)
            result?.forEach { (obj) in
                context?.delete(obj)
            }
        } completionBlock: {
            completion()
        }
    }
    
    func compute<Type: CoreDataExportable>(_ type: Type.Type, operation: String, keyPath: String, predicate: NSPredicate?) -> Int? {
        
        let context = viewContext
        let entityName = String(describing: Type.self)
        let fetchRequest = NSFetchRequest<NSDictionary>(entityName: entityName)
        
        fetchRequest.predicate = predicate
        fetchRequest.resultType = .dictionaryResultType
        
        let averageExpressionDesc = NSExpressionDescription()
        averageExpressionDesc.name = operation
        
        let specialAvgExp = NSExpression(forKeyPath: keyPath)
        averageExpressionDesc.expression = NSExpression(forFunction: operation, arguments: [specialAvgExp])
        averageExpressionDesc.expressionResultType = .integer64AttributeType
        
        fetchRequest.propertiesToFetch = [averageExpressionDesc]
        let result = context.safeFetch(fetchRequest)
        return result?.first?[operation] as? Int
    }
}


//MARK: - Private methods

private extension CoreDataStorageController {
    
    
    func save(saveBlock: @escaping () -> Void, completionBlock: @escaping () -> Void) {
        
        let context = backgroundContext
        context?.perform { [weak context] in
            saveBlock()
            context?.saveSelfAndParent() {
                DispatchQueue.main.async {
                    completionBlock()
                }
            }
        }
    }
    
    func insert<Type: CoreDataCompatible>(object: Type?, predicate: NSPredicate?, context: NSManagedObjectContext) {
        
        let type = Type.ManagedType.self
        let entityName = String(describing: type)
        let result = query(type: type, predicate: predicate, context: viewContext, fetchLimit: 1)?.first ??
                     NSEntityDescription.insertNewObject(forEntityName: entityName, into: context) as? Type.ManagedType
        result?.configure(with: object as! Type.ManagedType.ExportType, in: self)
    }
    
    func query<Type: NSManagedObject>(type: Type.Type, predicate: NSPredicate?, context: NSManagedObjectContext, sortDescriptors: [NSSortDescriptor]? = nil, fetchLimit: Int? = nil) -> [Type]? {
        
        // Fetch entity with appropriate class
        //
        let entityName = String(describing: Type.self)
        let fetchRequest = NSFetchRequest<Type>(entityName: entityName)
        fetchRequest.sortDescriptors = sortDescriptors
        fetchRequest.predicate = predicate
        
        if let limit = fetchLimit {
            fetchRequest.fetchLimit = limit
        }
        
        return context.safeFetch(fetchRequest)
    }
}


//MARK: Convenience saving context
//
private extension NSManagedObjectContext {
    
    func safeFetch<T>(_ request: NSFetchRequest<T>) -> [T]? where T : NSFetchRequestResult {
        
        do {
            return try fetch(request)
        }
        catch {
            Crashlytics.crashlytics().record(error: error)
            return nil
        }
    }
    
    var hasChanges: Bool {
        
        let registeredObjects = self.registeredObjects.filter { return $0.changedValues().count > 0 }
        let updatedObjects = self.updatedObjects.filter { return $0.changedValues().count > 0 }
        return (updatedObjects.count > 0) || (registeredObjects.count > 0) || !insertedObjects.isEmpty || !deletedObjects.isEmpty
    }
    
    func saveContextInstantly() {
        
        // Nothing to save
        //
        if !self.hasChanges { return }
        
        do {
            try save()
        } catch {
            Crashlytics.crashlytics().record(error: error)
            fatalError("Error  saving context: \(error)")
        }
    }
    
    func saveSelfAndParent(completion: (() -> Void)?) {
        saveContextInstantly()
        
        if (parent != nil) {
            parent?.perform({[weak self] in
                self?.parent?.saveSelfAndParent(completion: completion)
            })
        } else {
            completion?()
        }
    }
}

